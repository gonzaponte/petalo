use std::path::Path;

use crate::{
    config::mlem::Bounds,
    io::hdf5::read_dataset,
};

use units::{Length, Time, mm, ns};

// Use otherwise pointless module to allow nonstandard_style in constants
// generated by hdf5 derive macro
pub use grr::*;
#[allow(nonstandard_style)]
mod grr {

    #[derive(hdf5::H5Type, Clone, PartialEq, Debug)]
    #[repr(C)]
    pub struct SensorHit {
        pub event_id: u32,
        pub sensor_id: u32,
        pub time: f32,
    }

    #[derive(hdf5::H5Type, Clone, PartialEq, Eq, Debug)]
    #[repr(C)]
    pub struct Qtot {
        pub event_id: u32,
        pub sensor_id: u32,
        pub charge: u32,
    }

    #[derive(hdf5::H5Type, Clone, PartialEq, Debug)]
    #[repr(C)]
    pub struct SensorXYZ {
        pub sensor_id: u32,
        pub x: f32,
        pub y: f32,
        pub z: f32,
    }
}

// Combines individual SensorHit times with total charge.
#[derive(Clone, Copy, Debug)]
pub struct QT {
    pub event_id: u32,
    pub sensor_id: u32,
    pub q: u32,
    pub t: Time,
}

#[derive(Clone, Copy, Debug)]
pub struct SensorReadout {
    pub sensor_id: u32,
    pub x: Length,
    pub y: Length,
    pub z: Length,
    pub q: u32,
    pub t: Time,
}

pub fn read_sensor_hits(filename: &Path, range: Bounds<usize>) -> hdf5::Result<Vec<SensorHit>> {
    Ok(read_dataset::<SensorHit>(&filename, "MC/waveform", range)?.to_vec())
}

pub fn read_sensor_xyz(filename: &Path) -> hdf5::Result<Vec<SensorXYZ>> {
    Ok(read_dataset::<SensorXYZ>(&filename, "MC/sensor_xyz", Bounds::none())?.to_vec())
}

pub type SensorMap = std::collections::HashMap<u32, (Length, Length, Length)>;

pub fn read_sensor_map(filename: &Path) -> hdf5::Result<SensorMap> {
    let sensor_xyz = read_sensor_xyz(filename);
    Ok(make_sensor_position_map(sensor_xyz.unwrap()))
}

pub fn read_qts(infile: &Path, range: Bounds<usize>) -> hdf5::Result<Vec<QT>> {
    // Read charges and waveforms
    let qs = read_dataset::<Qtot     >(&infile, "MC/total_charge", range.clone())?;
    let ts = read_dataset::<SensorHit>(&infile, "MC/waveform"    , range        )?;
    Ok(combine_tables(qs, ts))
}

fn make_sensor_position_map(xyzs: Vec<SensorXYZ>) -> SensorMap {
    xyzs.iter().cloned()
        .map(|SensorXYZ{sensor_id, x, y, z}| (sensor_id, (mm(x), mm(y), mm(z))))
        .collect()
}

fn combine_tables(qs: ndarray::Array1<Qtot>, ts: ndarray::Array1<SensorHit>) -> Vec<QT> {
    let mut qts = vec![];
    let mut titer = ts.iter();
    for &Qtot{ event_id, sensor_id, charge:q} in qs.iter() {
        for &SensorHit{ event_id: te, sensor_id: ts, time:t} in titer.by_ref() {
            if event_id == te && sensor_id == ts {
                qts.push(QT{ event_id, sensor_id, q, t: ns(t) });
                break;
            }
        }
    }
    qts
}

// -------- Tests ------

#[cfg(test)]
mod test_h5sensors {
    use super::*;

    fn get_test_file() -> &'static Path {
        Path::new("src/io/mcead_test.h5")
    }

    #[test]
    fn test_read_sensor_hits() {
        let test_file = get_test_file();

        let sensor_hits = read_sensor_hits(test_file, Bounds::none());
        assert_eq!(sensor_hits.unwrap().len(), 8098);
    }

    #[test]
    fn test_read_sensor_xyz() {
        let test_file = get_test_file();

        let sensor_xyz = read_sensor_xyz(test_file);
        assert_eq!(sensor_xyz.unwrap().len(), 47428);
    }
}
