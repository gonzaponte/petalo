use std::path::Path;

use crate::{
    config::mlem::Bounds,
    io::hdf5::read_dataset,
};

// Use otherwise pointless module to allow nonstandard_style in constants
// generated by hdf5 derive macro
pub use grr::*;
#[allow(nonstandard_style)]
mod grr {

    #[derive(hdf5::H5Type, Clone, PartialEq, Debug)]
    #[repr(C)]
    pub struct Vertex {
        pub event_id: u32,
        pub track_id: u32,
        pub parent_id: u32,
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub t: f32,
        pub moved: f32,
        pub pre_KE: f32,
        pub post_KE: f32,
        pub deposited: u32,
        pub process_id: u32, // NB these may differ across
        pub volume_id: u32,  // different files
    }

    #[derive(hdf5::H5Type, Clone, PartialEq, Debug)]
    #[repr(C)]
    pub struct Primary {
        pub event_id: u32,
        pub x: f32,
        pub y: f32,
        pub z: f32,
        pub vx: f32,
        pub vy: f32,
        pub vz: f32,
    }
}

pub fn read_vertices(filename: &Path, range: Bounds<usize>) -> hdf5::Result<Vec<Vertex>> {
    Ok(read_dataset::<Vertex>(&filename, "MC/vertices", range)?.to_vec())
}

pub fn read_primaries(filename: &Path, range: Bounds<usize>) -> hdf5::Result<Vec<Primary>> {
    Ok(read_dataset::<Primary>(&filename, "MC/primaries", range)?.to_vec())
}

// -------- Tests ------

#[cfg(test)]
mod test_h5mc {
    use super::*;

    fn get_test_file() -> &'static Path {
        Path::new("src/io/mcead_test.h5")
    }

    #[test]
    fn test_read_vertices() {
        let test_file = get_test_file();

        let vertices = read_vertices(test_file, Bounds::none());
        let track_ids: Vec<u32> = vertices.unwrap().into_iter().map(|vrt| vrt.track_id).collect();
        assert_eq!(track_ids, [1, 1, 2, 4, 1]);
    }

    #[test]
    fn test_read_primaries() {
        let test_file = get_test_file();

        let primaries = read_primaries(test_file, Bounds::none());
        assert_eq!(primaries.unwrap().len(), 5);
    }
}
